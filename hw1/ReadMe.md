## Пояснения по задачам.

**1. Развернуть часть массива.**

В решение используется функция reverseArray, осуществляющая разворот массива с помощью механизма двух указателей. Элементы массива меняются местами друг с другом, поэтому дополнительная память не выделяется (если не считать память под указатели). Эта функция используется трижды - сначала разворачивается весь массив, потом часть до k-ого элемента, и наконец часть от k-ого элемента до конца. Решение имеет линейную сложность, так как каждый разворот массива осуществляется за O(n), где n - длина массива. Таких разворотов 3, но из математического анализа известно, что O(3n) = O(n).

**3. Слияние двух отсортированных массивов (без дополнительных аллокаций)**

Так как в конце первого массива уже выделено место под второй массив, записывая в него элементы с конца, мы априори не будем перекрывать элементы первого массива. Даже в случае, когда все элементы второго массива больше всех элементов первого, перезаписи не будет, так как тогда все элементы второго массива просто пойдут в конец.

**4. Сортировка массива из 0 и 1.**

В решении используется механизм двух указателей, первый изначально находится на левом конце массива, второй - на правом. Решение имеет линейную сложность, так как на каждом шаге один из указателей сдвигается (с возможной перестановкой двух элементов). Цикл продолжается до момента, когда указатели совпадут. Получается, будет выполнено n итераций, где n - длина массива. То есть сложность алгоритма линейная O(n).

**5. Задача флага Нидерландов.**

Используются 3 указателя - левый (l) указывает на границу нулей, правый (r) указывает на границу двоек, третий указатель (c) указывает на обрабатываемый элемент. На каждом шаге проверяется, какой элемент находится на позиции c. Если это 0 либо 2, происходит своп с элементами на позициях l и r соответственно, и эти указатели сдвигаются - происходит обновление границ. Также, для избежания ситуаций, когда левый указатель оказывается правее c, при сдвиге l на 1, с также сдвигается (по аналогии с 4 задачей).

**6. Передвинуть четные числа вперед.**

Используются 2 указателя - текущий элемент и место для следующего четного элемента. Совершается обход массива слева направо, каждый четный элемент обнаруживается в порядке их появления в массиве, и после перемещения на свою новую позицию больше не перемещается, что позволяет сохранить относительный порядок элементов.

**7. Нули в конец.**

Решение полностью аналогично 6 задаче, разница только в проверке - не на четность, а на неравенство нулю. Использование последовательно сдвигаемых указателей позволяет сохранить относительный порядок элементов.

## Запуск тестов

Если не установлен pytest:

```
python -m pip install pytest
```
Запустить тесты:
```
python -m pytest -q
```
